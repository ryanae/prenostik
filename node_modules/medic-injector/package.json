{
  "name": "medic-injector",
  "description": "A light-weight Javascript Dependency Injection tool, strongly inspired by the great ActionScript3 RobotLegs & SwiftSuspenders frameworks",
  "version": "0.2.4",
  "homepage": "https://github.com/DrBenton/Medic-Injector-JS",
  "repository": {
    "type": "git",
    "url": "git://github.com/DrBenton/Medic-Injector-JS.git"
  },
  "authors": [
    "Dr. Benton (http://github.com/DrBenton)"
  ],
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": "*"
  },
  "optionalDependencies": {},
  "scripts": {
    "test": "mocha test/"
  },
  "keywords": [
    "dependency",
    "injection",
    "injector"
  ],
  "engines": {
    "node": ">= 0.6"
  },
  "# vim: ts=2 sw=2 et ": null,
  "readme": "# Medic Injector\n\n[![build status](https://secure.travis-ci.org/DrBenton/Medic-Injector-JS.png)](http://travis-ci.org/DrBenton/Medic-Injector-JS)\n\nMedic Injector is a Javascript transcription of the great [SwiftSuspenders](https://github.com/tschneidereit/SwiftSuspenders)\nlight-weight ActionScript IoC container - coupled with the [RobotLegs](http://www.robotlegs.org/) framework, this is one of\nthe technologies with which I most enjoyed working, and I hope you will enjoy using this Javascript version too!\n\nIt lets you wire your application components in a very simple and intuitive way.\n\nYou setup your Injection Mappings once, and then use them everywhere you want in your application, without any overhead -\nInjections Points are recognized only from functions arguments names and Javascript objects instances properties names.\n\nIt can be used in Node.js and in the browser. If you use\n[Asynchronous Module Definition](https://github.com/amdjs/amdjs-api/wiki/AMD)\nin your client-side Javascript app, it will be particulary easy to add Medic Injector.\nIt is a very agnostic tool, which can be used in vanilla JS, Express server-side applications,\nBackbone browser-side applications, etc.\n\nIt is bundled with Unit Tests and [API documentation](http://drbenton.github.com/Medic-Injector-JS/api/).\n\n#### Medic Injector Sync\n\nA lighter implementation is available too, with synchronous Injections values resolutions only. It is less powerful but\nit is much more simple to use, since every operation immediately return its result instead of triggering a callback.\n\nIt's only 4kb when minified with UglifyJS.\n\nYou can look at the\n[medic-injector.sync.js](https://github.com/DrBenton/Medic-Injector-JS/blob/master/medic-injector.sync.js) file\nand [its unit tests](https://github.com/DrBenton/Medic-Injector-JS/blob/master/test/medic-injector.sync.js) for details,\nbut it is just a \"_immediate returned values instead of callbacks_\" version of the Medic Injector full asynchronous library\n(without the ```toModule()``` mapping, since it couldn't be synchronous in a browser AMD context).\n\nThe following Tutorial and Synopis use the full asynchronous version of Medic Injector.\n\n\n## Tutorial\n\nThere are two main phases to properly use this library : a \"injection mappings\" setup, then a \"injections points\" use in your\nwhole application.\n\nDuring the first phase, you create \"injection mappings\". Each injection mapping has a unique ID, and is linked to a value.\nThis value can be a Javascript scalar or object, but it can be bound to a more complex data source, like an asynchronous\nresource or a Node.js / AMD module. But we will see that later, for now let's look at the simplest dependency injection\nscheme:\n\n```javascript\n// Injector instance creation\nvar Injector = require('medic-injector').Injector;//with AMD you would use \"require(['medic-injector'], function() { /*your code*/ })\" instead\nvar injector = new Injector();\n\ninjector.addMapping('debug').toValue(true);//a first simple Injection Mapping\n\n// Later in you application code\nfunction displayHomepage (debug) {\n    render debug ? 'home.debug.html' : 'home.html';\n}\n\n// And later again\ninjector.triggerFunctionWithInjectedParams(displayHomepage);\n```\n\nWhat did we do? We just created an instance of a Medic Injector, and added a single Injection Mapping to , with a 'debug'\nunique ID and a simple boolean value.\nLater in the code, we asked the Injector to trigger a previously defined function. When it does this, it quickly parses\nthe arguments of the requested function, and for each argument it looks if an injection mapping has been registered with\nan ID matching the argument name. When an argument name matches an injection mapping ID, the value of the injection mapping\nwill be automatically injected in this argument.\n\nWe can also use injections points in a OOP code. With the same setup than the previous example, we can do this :\n\n```javascript\nvar Logger = function ()\n{\n    this.debug = null;\n};\nvar logger = new Logger();\ninjector.injectInto(logger);\n```\n\nAfter this \"injectInto()\" call, our Logger instance will have its \"debug\" property set to 'true'. The Logger can even\n call the injector itself:\n\n```javascript\nvar Logger = function ()\n{\n this.debug = null;\n this.postInjections = function () {\n    // If an \"injected\" object instance has a \"postInjections\" method, it will be automatically triggered\n    // after the injections resolution (injections mapping can be asynchronous).\n    // It can be considered as a \"second constructor\", called when you object instance is really ready, with all its\n    // injected dependencies resolved.\n    this.dispatchEvent('ready');\n };\n\n injector.injectInto(this);\n};\n```\n\nOk, this 'debug' property was not a very interesting injection. Let's see something more advanced:\n\n```javascript\n// a new \"value\" Injection Mapping...\ninjector.addMapping('appConfig').toValue({\n    mode: 'development',\n    db: {host: 'localhost', db: 'test'},\n    mail: {host: 'smtp.gmail.com', user: 'webmaster@test.com', password: ''},\n});\n\n// ...and a new type of Injection Mapping, used with the \"toProvider\" method\ninjector.addMapping('csrf').toProvider(function () {\n    return CsrfGenerator.getNewToken();\n});\n```\nThe 'csrf' injection mapping is not linked to a simple value, but to a \"Provider\" return value. A Provider is simply\na function that returns a value, immediatly like the 'csrf' one or asynchronously.\nEach time a function used with the Injector will have a 'csrf' argument or a custom Javascript type will have a 'csrf'\nproperty initially set to 'null', the injector will set this argument/property value to a new\n[CSRF token](http://en.wikipedia.org/wiki/Cross-site_request_forgery).\n\nWhat if our 'CsrfGenerator' has an asynchronous flow ? Well, it's simple, you just have to add a 'callback' argument\nto your Provider function, and the Medic Injector will consider the Provider as an asynchronous one. In such a cas,\ninstead of getting the return value of your Provider it will wait for a 'callback' call. When this function will be\ntriggered by your Provider, it will have to call it with a single argument, which will be considered as the Injection Mapping\nvalue:\n\n```javascript\ninjector.addMapping('csrf').toProvider(function (callback) {\n    CsrfGenerator.getNewToken(function (err, result) {\n        err && throw err;\n        callback(result);//the 'result' value will be our 'csrf' Injection Mapping value.\n    });\n});\n```\nNote that this Provider will be triggered each time this Injection Mapping is requested by one of your functions or one\nof your JS custome types. For some mappings you will probably want to trigger the Provider only once. Well, that's simple,\nyou just have to add a \"asSingleton()\" call to your Injection Mapping:\n\n```javascript\n// DB connection : it will be \"lazy-triggered\", only when the injection mapping is requested for the first time\ninjector.addMapping('db')\n    .toProvider(function (appConfig) {//the previously defined \"app config\" will be automatically injected in this provider\n        var mongoose = require('mongoose');\n        var db = mongoose.createConnection(appConfig.db.host, appConfig.db.db);\n        return db;\n    })\n    .asSingleton();//shared singleton instance\n```\nAs you can see, we have define a 'db' Injection Mapping, which will return a new MongoDB connection. Because we used the\n\"asSingleton()\" method, it will be created only when it is first requested, and then the same shared instance will always be\ninjected.\n\nYou may have noticed on the last example that the Provider has a \"appConfig\" argument, used in the Provider.\nThat's a key feature of the Medic Injector : all Injections Mappings can themselves  recursively request others\nInjections Mapping, just by using Injections Mappings IDS in their Provider function argument. This system can handle as many\nInjections Mappings nested levels as you need, and handle asynchonous ones automatically.\n\nFor asynchronous Providers you can mix the \"callback\" argument with others injections depencies arguments.\n\nYou can also use injection on simple Strings, with the \"${injectionName}\" pattern:\n\n```javascript\nvar sourceStr = '::${username}::${csrf}::';\ninjector.parseStr(sourceStr, function (injectedStr) {\n    // injectedStr = '::john::eklm4p12::'\n});\n```\n\nNow that you've seen these simple examples, you may take a look at the following synopsis, which use all this and introduce\na new Injection Mapping type, used with the \"toModule()\" method.\n\n\n## Synopsis\n\nIn a \"app/bootstrap.js\" file, the injection mappings initialization:\n\n```javascript\n\n// Injector instance creation\nvar Injector = require('medic-injector');//with AMD you would use \"require(['medic-injector'], function() { ... })\" instead\nvar injector = new Injector();\n\n// Simplest injections : just simple values\n// Every time an entity declares an injection point whose name matches this injection name, this injection point value will\n// be automatically set to this injection mapping value.\ninjector.addMapping('debug').toValue(true);\ninjector.addMapping('appConfig').toValue({\n    mode: 'development',\n    db: {host: 'localhost', db: 'test'},\n    mail: {host: 'smtp.gmail.com', user: 'webmaster@test.com', password: ''},\n});\n\n// Types injections : an instance of the given JS type will be created on demand when an entity declares an injection point\n// whose name matches this injection name\ninjector.addMapping('logger').toValue(Logger).asSingleton();//when \"asSingleton()\" is used, the first created instance will always be be injected\ninjector.addMapping('swig').toValue(Swig).asSingleton();\n\n// Module injections : can be used in Node.Js or in an AMD environment\ninjector.addMapping('subscribeFormTemplate').toModule('./view/subscribe-form-template.html');\ninjector.addMapping('inherits').toModule('util' 'inherits');\n\n// Providers injections : the given function is triggered on demand when an entity declares an injection point\n// whose name matches this injection name\ninjector.addMapping('csrf')\n    .toProvider(function () {\n        return CsrfGenerator.getNewToken();\n    });\ninjector.addMapping('db')\n    .toProvider(function (appConfig) {//the previously defined \"app config\" will be automatically injected in this provider\n        var mongoose = require('mongoose');\n        var db = mongoose.createConnection(appConfig.db.host, appConfig.db.db);\n        return db;\n    })\n    .asSingleton();//shared singleton instance\ninjector.addMapping('mailer')\n    .toProvider(function (appConfig) {\n        var mailer = new Mailer();\n        mailer.host = appConfig.mail.host;\n        mailer.user = appConfig.mail.user;\n        mailer.password = appConfig.mail.password;\n        return mailer;\n    })\n    .asSingleton();//shared singleton instance\ninjector.addMapping('subscribeFormHtml')\n    .toProvider(function (csrf, subscribeFormTemplate, swig) { //these previously defined injections mappings will be automatically injected in this provider\n        var tmpl = swig.compileFile(subscribeFormTemplate);\n        tmpl.render({\n            csrf: csrf\n        });\n    });\ninjector.addMapping('currentUser')\n    .toProvider(function (db, callback) { //Providers can be asynchronous too (if they have a \"callback\" arg, they are considered as async Providers)\n        var UserModel = db.model('User');\n        MyModel.findOne({id: req.session.userId}, function (err, user) {\n            err && throw err;\n            callback(user);\n        });\n    });\n    .asSingleton();//shared singleton instance\n```\n\nIn a \"app/subscribe-form.js\" file, injection mappings use:\n\n```javascript\nvar SubscribeForm = function () {\n\n    // This prop value will be automatically set to the shared \"mailer\" instance\n    this.mailer = null;\n    // This prop value will be automatically set to a new rendered \"subscribe form\", with a new CSRF token\n    this.subscribeFormHtml = null;\n    // This prop value will be automatically set to the shared \"UserModel\" instance\n    this.currentUser = null;\n\n    // This JS type will be \"auto-injected\"\n    injector.injectInto(this);\n\n};\nSubscribeForm.prototype.postInjections = function() {\n    // This method will be automatically triggered when all this instance injection points will have been resolved\n    // It's a sort of \"post injections\" constructor\n};\nSubscribeForm.prototype.display = function(req, res) {\n    res.render(this.subscribeFormHtml);\n};\n\nmodule.exports = SubscribeForm;\n\n```\n\n## API\n\nSee the API here : http://drbenton.github.com/Medic-Injector-JS/api/\n\nThe API is generated with [JSDuck](https://github.com/senchalabs/jsduck) with the following command:\n\n    $ jsduck --output docs/api/ medic-injector.js medic-injector.sync.js\n\n\n## Running Tests\n\nTo run the test suite you will need to have the [Mocha](http://visionmedia.github.com/mocha/) library globally installed.\nIf you don't already have it, just invoke the following command:\n\n    $ npm install -g mocha\n\nThen invoke this command within the Medic Injector folder:\n\n    $ npm test\n\n\n## License\n(The MIT License)\n\nCopyright (c) 2012 Olivier Philippon <https://github.com/DrBenton>\n\nContains snippets of code from [Q](https://github.com/kriskowal/q) and [Prototype](https://github.com/sstephenson/prototype) libraries. See their specific licenses for details.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/DrBenton/Medic-Injector-JS/issues"
  },
  "_id": "medic-injector@0.2.4",
  "dist": {
    "shasum": "bd436fb975b1bf8f54ded04d4e539dd7006fda3e"
  },
  "_from": "medic-injector@~0.2.4",
  "_resolved": "https://registry.npmjs.org/medic-injector/-/medic-injector-0.2.4.tgz"
}
